# Miaosha
秒杀系统设计以及优化学习
# 项目介绍
## 一 环境搭建
使用Spring Boot和MyBAtis搭建开发环境；
集成Thymleaf模板引擎，为方便前端展示，使用Result封装结果集；
数据库使用MySQL和Redis缓存

## 登录功能
使用两次MD5处理，提高安全性，第一次MD5是在前端防止明文密码在传输过程中泄漏，第二次MD5在后端做，使用第一次MD5加密后的密文+salt，数据库只保存第二次MD5后的值和salt。
对登录的手机号格式进行Validator校验。

用到登录的时候会分发一个session，存入Redis，实现了一个简单的分布式session的功能。session并没有存到服务器端数据库，而是存到了Redis里面，设置过期时间，当用户重新登录的时候还可以延长有效期。
## 商品页
有商品列表，商品详情，订单详情页；
为了便于扩展，数据库表设计为商品表，秒杀商品表，进行商品详情页面展示的设计把他们包装成一个GoodsVo的类。
## 页面优化
页面优化主要是：页面缓存和页面静态化（前后端分离）；
1）页面缓存，URL缓存
在访问页面的时候，请求不是直接通过服务器来渲染，而是首先从缓存里面取。找到了，直接返回给客户端，如果没有，手动来渲染模板。渲染出来之后再把结果输出给客户端。同时把结果缓存到Redis里面，下次就可以使用了。
三步：
1）取缓存，若能取到则直接返回取到的值，否则继续
2）手动渲染模板
3）结果输出
首先从缓存里取，看能不能取到。
注入ThymeleafViewResolver
 @Autowired
 ThymeleafViewResolver thymeleafViewResolver;页面缓存的有效期一般比较短。对goods_list页面进行静态化。之前是把数据放到model里面，渲染到页面上的。
把之前的Controller接口改成@ResponseBody的，
设置页面缓存时间为60秒，设置Redsi的key 的过期时间。

2）页面静态化（前后端分离）
页面静态化是一种更为激进的缓存，它直接把静态页面缓存到了用户的浏览器上。这样做的好处是当用户访问页面的时候，就不需要跟服务端进行交互了，直接从本地缓存拿到页面就可以了。极大地节省网络流量，提供响应速度。
服务端只需要写接口就可以了。
## 解决超卖现象和用户重复秒杀
从数据库层面解决
1）数据库加唯一索引：防止用户重复购买；
2）SQL加库存数量判断：防止库存变为负数。

@Update("update miaosha_goods set stock_count = stock_count - 1 where goods_id = #{goodsId} and stock_count > 0")
 public int reduceStock(MiaoshaGoods g);
在原SQL语句中加上：and stock_count > 0"
只有在库存大于0的时候才减库存。
因为数据库的更新操作会在数据库当前行上加一个锁，不会出现两个线程同时更新的情况。

防止一个用户多次秒杀，利用数据库的唯一索引。
在miaosha_order中加唯一索引u_uid_gid 栏位 user_id,goods_id Unique
当重复插入的时候会报错，报错就会回滚。来保证商品绝对不会卖超。
## 秒杀接口
Redis预减库存减少数据库访问，
内存标记减少Redis访问，
RabbitMQ队列缓存，异步下单，增强用户体验

秒杀的瓶颈这数据库，所以目的是减少数据库的访问。
1）首先系统初始化把商品库存放到Redis里面，实现一个InitializingBean接口，实现aferPropertiesSet（）方法。当容器初始化的时候，当它发现你实现了InitializingBean接口，它就会回调aferPropertiesSet（）方法。
从GoodsService中获取GoodsList，若获取结果为null，则什么也不做，返回。
如果有商品，则循环把goodsID和goods库存加入到Redis里面。
2）收到请求，Redis预减库存，即商品对于的库存减1，若库存不足直接返回，否则进入3。（这一步可以减少大量的不必要的数据库访问）
3）请求进入消息队列队，先立即返回秒杀排队中，其余交给队列消费者异步处理；
4）请求出队，判断该用户是否秒杀过，若没有秒杀过，则生成订单，减少库存
5）客户端轮询，是否秒杀成
其中4和5是并发进行的。

（使用Redis预减库存，库存为0之后的所有请求直接返回失败，后面无论有多少个请求对数据库都没有影响）如何在系统初始化的时候把库存加载到Redis缓存中呢？
实现一个InitializingBean接口，实现aferPropertiesSet（）方法。当容器初始化的时候，当它发现你实现了InitializingBean接口，它就会回调aferPropertiesSet（）方法。
从GoodsService中获取GoodsList，若获取结果为null，则什么也不做，返回。
如果有商品，则循环把goodsID和goods库存加入到Redis里面。
内存标记减少Redis的访问：
即使是访问Redis也是由网络开销的，尽量把网络开销也减少。
若模块商品已经卖完了，就没有必要访问Redis了，可以把该商品是否买完存到一个ConcurrentHashMap中。若卖完了，直接返回，不用再访问Redis了。
## 安全优化
接口地址隐藏和接口限流防刷
1）秒杀接口地址隐藏
在秒杀开始之前，秒杀的地址不是写死的，而是需要从服务端获取，拼接生成的。秒杀开始之前，你是不知道要访问哪一个URL的。这样会比较安全。
秒杀之前前端首先获取秒杀的Path，把goodID提交过来，由miaoshaService生成一个uuid的path，然后用这个path拼接do_miaosha的路径才能访问成功。
2）接口限流防刷
限制用户在一段时间内只能访问多少次。
思路：
对接口做限流。
在一个用户访问接口的时候 ，把访问次数写在缓存里面。同时给数据加一个有效期（比如一分钟）。
一分钟以内再有访问把数据加1，如果一分钟之内超过限定数值了，我们之间返回失败。如果一分钟之内没有超过次数，下次重新计算次数，一分钟有效期。
在进入该方法前加一个拦截器@AccessLimit（second=5, maxCount=5,needLogin=true），对访问次数进行判断。
在每个方法前都要进行访问次数的判断，可以把这些通用的代码提前出来，用拦截器实现，类似的还有登录的验证。
